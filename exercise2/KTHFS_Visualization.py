#!/usr/bin/env python3
"""
Features:
 - h(t) = 3 * pi * exp(-lambda(t)), lambda(t)=5*sin(2*pi*1*t)
 - Real-time sampling (system clock) and prerecorded playback (CSV with time_s,value)
 - Start/Stop/Reset, Pause/Resume (Space), Save CSV (S), Load CSV (L), Export TikZ (T)
 - Zoom slider (window width), Grid toggle, Follow mode
 - Experiment name entry, Save CSV with metadata
 - Export TikZ/PGFPlots code to a .tex file suitable for inclusion in LaTeX
"""

import sys
import os
import time
import datetime
import numpy as np
import pandas as pd

from PyQt5.QtGui import QKeySequence   # QShortcut removed here
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QPushButton, QVBoxLayout, QHBoxLayout,QComboBox,
    QLabel, QLineEdit, QSlider, QFileDialog, QMessageBox, QCheckBox, QShortcut,QDoubleSpinBox
)

from PyQt5.QtCore import Qt, QTimer, QEvent

import matplotlib
matplotlib.use("Qt5Agg")
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure


# -------------------------
# Data classes

class Plotter:
    """Base plotting class (buffer management)."""
    def __init__(self):
        self.t = []  # seconds
        self.y = []

    def add_sample(self, t, value):
        self.t.append(float(t))
        self.y.append(float(value))

    def clear(self):
        self.t.clear()
        self.y.clear()

    def get_dataframe(self):
        return pd.DataFrame({"time_s": self.t, "value": self.y})

    def load_dataframe(self, df):
        """Replace buffers with provided DataFrame (expects time_s, value)."""
        self.t = df["time_s"].astype(float).tolist()
        self.y = df["value"].astype(float).tolist()

class SineExpPlotter(Plotter):
    """h(t) = 3*pi*exp(-lambda(t)), lambda(t)=5*sin(2*pi*1*t)."""
    @staticmethod
    def h_of_t(t):
        t_arr = np.array(t, dtype=float)
        lam = 5.0 * np.sin(2.0 * np.pi * 1.0 * t_arr)
        return 3.0 * np.pi * np.exp(-lam)

# -------------------------
# TikZ export helper

def export_to_tikz(df, out_path, axis_options=None, caption=None, label=None):
    """
    Export DataFrame (time_s, value) to a TikZ/PGFPlots snippet.
    Writes a .tex file containing an axis environment with a table of data.
    """
    axis_opts = axis_options or "width=\\linewidth, height=6cm, xlabel={$t$ [s]}, ylabel={$h(t)$}"
    caption = caption or "Plot exported from kthfsdv_plotter"
    label = label or "fig:kthfsdv_plot"

    # Limit number of points to something reasonable for TikZ (downsample if needed)
    max_points = 2000
    if len(df) > max_points:
        # uniform downsample
        idx = np.linspace(0, len(df)-1, max_points, dtype=int)
        df_small = df.iloc[idx]
    else:
        df_small = df

    with open(out_path, "w") as f:
        f.write("% Generated by kthfsdv_plotter\n")
        f.write("\\begin{figure}[ht]\n\\centering\n")
        f.write("\\begin{tikzpicture}\n")
        f.write("  \\begin{axis}[%s]\n" % axis_opts)
        f.write("    \\addplot table[row sep=\\newline, col sep=space] {\n")
        f.write("      t value\n")
        for tt, vv in zip(df_small["time_s"], df_small["value"]):
            f.write(f"      {tt:.6f} {vv:.12e}\n")
        f.write("    };\n")
        if caption:
            f.write(f"    \\caption{{{caption}}}\n")
        if label:
            f.write(f"    \\label{{{label}}}\n")
        f.write("  \\end{axis}\n\\end{tikzpicture}\n\\end{figure}\n")

# -------------------------
# Main PyQt Application

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("kthfsdv Plotter — PyQt5")
        self.resize(1000, 650)

        # Plotter and state
        self.plotter = SineExpPlotter()
        self.mode = "realtime"  # "realtime" or "prerecorded"
        self.prerec_df = None
        self.prerec_idx = 0
        self.prerec_start_wall = None 
        self.prerec_playback_speed = 1.0

        # Sampling and timer
        self.dt = 0.01
        self.timer = QTimer(self)
        self.timer.setInterval(int(self.dt * 1000))
        self.timer.timeout.connect(self.on_timer_tick)
        self.is_running = False
        self.is_paused = False

        self._build_ui()

        QShortcut(QKeySequence("Space"), self, activated=self.toggle_pause)
        QShortcut(QKeySequence("S"), self, activated=self.save_csv)
        QShortcut(QKeySequence("L"), self, activated=self.load_prerecorded)
        QShortcut(QKeySequence("T"), self, activated=self.export_tikz_dialog)

        self.redraw_plot()

    def _build_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Matplotlib Figure
        self.fig = Figure(figsize=(8,4))
        self.ax = self.fig.add_subplot(111)
        self.ax.set_xlabel("time [s]")
        self.ax.set_ylabel("h(t)")
        self.ax.set_title("h(t) = 3π·exp(-λ(t)), λ(t)=5·sin(2π·t)")
        self.ax.grid(True)
        self.line, = self.ax.plot([], [], linewidth=1)

        self.canvas = FigureCanvas(self.fig)
        layout.addWidget(self.canvas)

        # Controls: two rows
        row1 = QHBoxLayout()
        layout.addLayout(row1)

        # Start/Stop/Reset
        self.btn_start = QPushButton("Start")
        self.btn_start.clicked.connect(self.start)
        row1.addWidget(self.btn_start)

        self.btn_stop = QPushButton("Stop")
        self.btn_stop.clicked.connect(self.stop)
        self.btn_stop.setEnabled(False)
        row1.addWidget(self.btn_stop)

        self.btn_reset = QPushButton("Reset")
        self.btn_reset.clicked.connect(self.reset)
        row1.addWidget(self.btn_reset)

        # Pause/Resume
        self.btn_pause = QPushButton("Pause (Space)")
        self.btn_pause.clicked.connect(self.toggle_pause)
        self.btn_pause.setEnabled(False)
        row1.addWidget(self.btn_pause)

        # Mode selector
        row1.addSpacing(10)
        row1.addWidget(QLabel("Mode:"))
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["realtime", "prerecorded"])
        self.mode_combo.currentTextChanged.connect(self.on_mode_changed)
        row1.addWidget(self.mode_combo)

        # Playback speed (for prerecorded)
        row1.addWidget(QLabel("Speed:"))
        self.speed_spin = QDoubleSpinBoxWithDecimals()
        self.speed_spin.setRange(0.1, 10.0)
        self.speed_spin.setValue(1.0)
        self.speed_spin.setSingleStep(0.1)
        self.speed_spin.valueChanged.connect(self.on_speed_changed)
        row1.addWidget(self.speed_spin)

        # Load prerecorded button
        self.btn_load = QPushButton("Load CSV (L)")
        self.btn_load.clicked.connect(self.load_prerecorded)
        row1.addWidget(self.btn_load)

        # Save CSV button
        self.btn_save = QPushButton("Save CSV (S)")
        self.btn_save.clicked.connect(self.save_csv)
        row1.addWidget(self.btn_save)

        # Export TikZ
        self.btn_tikz = QPushButton("Export TikZ (T)")
        self.btn_tikz.clicked.connect(self.export_tikz_dialog)
        row1.addWidget(self.btn_tikz)

        # Row 2 controls: zoom, follow, grid, experiment name, window width
        row2 = QHBoxLayout()
        layout.addLayout(row2)

        row2.addWidget(QLabel("Window (s):"))
        self.zoom_slider = QSlider(Qt.Horizontal)
        self.zoom_slider.setRange(1, 300)  
        self.zoom_slider.setValue(50)      
        self.zoom_slider.valueChanged.connect(self.on_zoom_changed)
        row2.addWidget(self.zoom_slider)
        self.window_width = 5.0

        self.chk_grid = QCheckBox("Grid")
        self.chk_grid.setChecked(True)
        self.chk_grid.stateChanged.connect(lambda _: self.redraw_plot())
        row2.addWidget(self.chk_grid)

        self.chk_follow = QCheckBox("Follow")
        self.chk_follow.setChecked(True)
        row2.addWidget(self.chk_follow)

        row2.addWidget(QLabel("Experiment:"))
        self.exp_edit = QLineEdit("exp1")
        row2.addWidget(self.exp_edit)

        # status label
        self.status_label = QLabel("Stopped")
        row2.addWidget(self.status_label)

        # make widgets expand nicely
        row2.addStretch()

        # make canvas expand
        central.setLayout(layout)

    # -------------------------
    # Controls / events

    def start(self):
        if not self.is_running:
            self.is_running = True
            self.is_paused = False
            self.btn_start.setEnabled(False)
            self.btn_stop.setEnabled(True)
            self.btn_pause.setEnabled(True)
            self.btn_pause.setText("Pause (Space)")
            
            if self.mode == "realtime":
                # continue from current_t if any
                # set baseline such that current_t continues to increment smoothly
                if len(self.plotter.t) == 0:
                    self._realtime_start_wall = time.time()
                    self._realtime_offset = 0.0
                else:
                    # continue from last timestamp
                    last_t = self.plotter.t[-1]
                    self._realtime_start_wall = time.time() - last_t
                    self._realtime_offset = 0.0
            else:
                # prerecorded mode: prepare playback indices and wall clock mapping
                if self.prerec_df is None:
                    QMessageBox.warning(self, "No prerecorded data", "Load a CSV file before starting prerecorded playback.")
                    self.is_running = False
                    return
                # start playback at current prerec_idx (or 0)
                self.prerec_start_wall = time.time()
                # if index > 0, we align so that current wall -> time at prerec_idx
                # We'll compute elapsed playback time = (now - prerec_start_wall) * speed
            self.timer.start()
            self.status_label.setText("Running")

    def stop(self):
        if self.is_running:
            self.timer.stop()
            self.is_running = False
            self.btn_start.setEnabled(True)
            self.btn_stop.setEnabled(False)
            self.btn_pause.setEnabled(False)
            self.btn_pause.setText("Pause (Space)")
            self.status_label.setText("Stopped")

    def reset(self):
        self.stop()
        self.plotter.clear()
        self.prerec_idx = 0
        self.prerec_start_wall = None
        self.is_paused = False
        self.status_label.setText("Reset")
        self.redraw_plot()

    def toggle_pause(self):
        if not self.is_running:
            return
    
        self.is_paused = not self.is_paused
        if self.is_paused:
            self.btn_pause.setText("Resume (Space)")
            self.status_label.setText("Paused")
        else:
            
            self.btn_pause.setText("Pause (Space)")
            self.status_label.setText("Running")

    def on_mode_changed(self, text):
        self.mode = text
        # Enable/disable controls depending on mode
        if self.mode == "prerecorded":
            self.speed_spin.setEnabled(True)
            self.btn_load.setEnabled(True)
        else:
            self.speed_spin.setEnabled(False)
            
        self.prerec_idx = 0
        self.prerec_start_wall = None

    def on_speed_changed(self, val):
        self.prerec_playback_speed = float(val)

    def load_prerecorded(self):
        path, _ = QFileDialog.getOpenFileName(self, "Load prerecorded CSV", "", "CSV files (*.csv);;All files (*)")
        if not path:
            return
        try:
            df = pd.read_csv(path, comment="#")
            
            cols = [c.lower() for c in df.columns]
            if "time_s" in cols and "value" in cols:
                
                df.columns = [c.lower() for c in df.columns]
                df = df[["time_s", "value"]].dropna().reset_index(drop=True)
            else:
                raise ValueError("CSV must contain 'time_s' and 'value' columns.")
        except Exception as e:
            QMessageBox.critical(self, "Load failed", f"Failed to load CSV:\n{e}")
            return
        self.prerec_df = df
        self.plotter.load_dataframe(df)  # optionally load into buffer so initial plot shows
        self.prerec_idx = 0
        self.prerec_start_wall = None
        self.mode_combo.setCurrentText("prerecorded")
        self.status_label.setText(f"Loaded {len(df)} samples")
        self.redraw_plot()

    def save_csv(self):
        if len(self.plotter.t) == 0:
            QMessageBox.information(self, "No data", "No data to save.")
            return
        df = self.plotter.get_dataframe()
        exp_name = self.exp_edit.text().strip()
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        default_name = f"{exp_name or 'exp'}_{timestamp}.csv"
        path, _ = QFileDialog.getSaveFileName(self, "Save CSV", default_name, "CSV files (*.csv);;All files (*)")
        if not path:
            return
        meta = {"experiment": exp_name, "saved_at": datetime.datetime.now().isoformat(), "samples": len(df)}
        try:
            with open(path, "w") as f:
                f.write("# " + ", ".join([f"{k}={v}" for k, v in meta.items()]) + "\n")
            df.to_csv(path, mode="a", index=False)
            QMessageBox.information(self, "Saved", f"Saved {len(df)} samples to:\n{path}")
        except Exception as e:
            QMessageBox.critical(self, "Save failed", f"Failed to save CSV:\n{e}")

    def export_tikz_dialog(self):
        if len(self.plotter.t) == 0:
            QMessageBox.information(self, "No data", "No data to export.")
            return
        path, _ = QFileDialog.getSaveFileName(self, "Export TikZ (.tex)", "plot.tex", "TeX files (*.tex);;All files (*)")
        if not path:
            return
        try:
            df = self.plotter.get_dataframe()
            caption = f"{self.exp_edit.text().strip() or 'experiment'}"
            label = f"fig:{os.path.splitext(os.path.basename(path))[0]}"
            export_to_tikz(df, path, axis_options=None, caption=caption, label=label)
            QMessageBox.information(self, "Exported", f"TikZ file written to:\n{path}")
        except Exception as e:
            QMessageBox.critical(self, "Export failed", f"Failed to export TikZ:\n{e}")

    # -------------------------
    # Timer tick: produce or play samples
    
    def on_timer_tick(self):
        if not self.is_running or self.is_paused:
            return

        if self.mode == "realtime":
            # sample using monotonic system clock relative to first call
            if not hasattr(self, "_realtime_start_wall") or self._realtime_start_wall is None:
                self._realtime_start_wall = time.time()
            t_now = time.time() - self._realtime_start_wall
            v = float(SineExpPlotter.h_of_t(t_now))
            self.plotter.add_sample(t_now, v)
        else:
            # prerecorded playback: advance index according to real elapsed wall time * speed
            if self.prerec_df is None or len(self.prerec_df) == 0:
                return
            now_wall = time.time()
            if self.prerec_start_wall is None:
                # start playback now
                self.prerec_start_wall = now_wall
                # playback starting at current idx  (0)
                self.playback_base_time = self.prerec_df["time_s"].iloc[self.prerec_idx]
            
            elapsed = (now_wall - self.prerec_start_wall) * self.prerec_playback_speed
            target_time = self.playback_base_time + elapsed
            
            n = len(self.prerec_df)
            while self.prerec_idx < n and self.prerec_df["time_s"].iloc[self.prerec_idx] <= target_time:
                row_t = float(self.prerec_df["time_s"].iloc[self.prerec_idx])
                row_v = float(self.prerec_df["value"].iloc[self.prerec_idx])
                self.plotter.add_sample(row_t, row_v)
                self.prerec_idx += 1
            # Stop at end automatically
            if self.prerec_idx >= n:
                self.stop()
                self.status_label.setText("Finished playback")

        # redraw plot each tick
        self.redraw_plot()

    # -------------------------
    # Plotting and UI helpers

    def redraw_plot(self):
        if len(self.plotter.t) == 0:
            self.line.set_data([], [])
            self.ax.set_xlim(0, self.window_width)
            self.ax.set_ylim(-1, 1)
            self.ax.grid(self.chk_grid.isChecked())
            self.canvas.draw_idle()
            return

        t = np.array(self.plotter.t)
        y = np.array(self.plotter.y)
        self.line.set_data(t, y)

        # Y autoscale with margin
        y_min, y_max = float(np.min(y)), float(np.max(y))
        if y_min == y_max:
            y_min -= 0.5
            y_max += 0.5
        else:
            pad = 0.08 * (y_max - y_min)
            y_min -= pad
            y_max += pad
        self.ax.set_ylim(y_min, y_max)

        # X axis window
        if self.chk_follow.isChecked():
            t_end = t[-1]
            t_start = max(0.0, t_end - self.window_width)
            self.ax.set_xlim(t_start, t_start + self.window_width)
        else:
            self.ax.set_xlim(max(0.0, t[0]), max(t[-1], t[0] + self.window_width))

        self.ax.grid(self.chk_grid.isChecked())
        self.canvas.draw_idle()

    def on_zoom_changed(self, val):
    
        v = self.zoom_slider.value()
        self.window_width = v / 10.0
        self.redraw_plot()

# -------------------------
# QDoubleSpinBox replacement with decimals that works well

class QDoubleSpinBoxWithDecimals(QDoubleSpinBox):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDecimals(2)
        
        self.setRange(-1e9, 1e9)
        self.setSingleStep(0.1)

# -------------------------
# Main entry

def main():
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
